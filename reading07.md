# Reading 6 - JavaScript 102

Really amazing how JavaScript treats variable type (like 1 versus "1") with built-in comparison operators to check for type and equality (or not) based on a number of conversion rules.Â  I haven't seen === before (Google says it's used also in PHP and Ruby). While I grow accustomed to this version of type-checking, I'll still reference the docs and tread carefully before making a comparison, say, with <= or >= to be sure how it will behave - not just with number values, but with the inferred values, like the value of "beef", as well as with a number of special return cases like for NaN (not a number), null, and undefined.  Furthermore, there do seem to be a number of error types to get famililar with soon.  Finally, I mentioned in the last post that JavaScript may continue to run without complaining (or crashing) after conditions that could have crashed programs in other languages.  Still learning how this works, but the browser's developer console is a good place to check for error messages that might not otherwise be apparent.  Looking forward to learning a lot about best practices and norms soon, because without care - it seems vanilla JavaScript, while fun, could be a dangerous tool.  

[Back to Home](https://stephen-montague.github.io/reading-notes/)
